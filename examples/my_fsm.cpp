#include <string>
#include <vector>
#include <functional>
#include <iostream> // For example actions/preds
#include <unordered_set>
#include <string_view>
#include <map>
#include <sstream>

// Forward declare or include StringInterner
class StringInterner {
public:
    static StringInterner& instance() {
        static StringInterner inst;
        return inst;
    }
    std::string_view intern(const std::string& str) {
        auto [it, inserted] = pool_.insert(str);
        return std::string_view(*it);
    }
private:
    std::unordered_set<std::string> pool_; // C++17 needs #include <unordered_set>
};


// User defines this struct
struct Transition {
    std::string_view from_state;
    std::vector<std::function<bool()>> predicates;
    std::vector<std::function<void()>> actions;
    std::string_view to_state;
};

/* FSMgine definition: MyCoolMachine
(IDLE PRED p_isReady ACTION a_doSetup READY)
(READY PRED p_hasEvent ACTION a_processEvent IDLE)
(READY ACTION a_enterError ERROR)
(IDLE PRED p_hasEvent ACTION a_enterError ERROR)
*/
// The user ensures this macro name matches the definition name above
#define FSM_MyCoolMachine_transitions {}



class MyCoolFSM {
public:
    MyCoolFSM(const std::string& initial_state_name) {
        current_state_ = StringInterner::instance().intern(initial_state_name);
        // Initialize transitions using the macro generated by FSMgine
        transitions_ = FSM_MyCoolMachine_transitions; // This line uses the generated code
        std::cout << "MyCoolFSM initialized. Transitions loaded: " << transitions_.size() << std::endl;
    }

    void step() { // Example FSM execution step
        std::cout << "Current state: " << current_state_ << std::endl;
        for (const auto& rule : transitions_) {
            if (rule.from_state.data() == current_state_.data()) {
                bool all_preds_true = true;
                for (const auto& pred_func : rule.predicates) {
                    if (!pred_func()) {
                        all_preds_true = false;
                        break;
                    }
                }
                if (all_preds_true) {
                    std::cout << "  Transition triggered from " << rule.from_state << std::endl;
                    for (const auto& act_func : rule.actions) {
                        act_func();
                    }
                    current_state_ = rule.to_state;
                    std::cout << "  New state: " << current_state_ << std::endl;
                    return; // Take first matching transition
                }
            }
        }
        std::cout << "  No transition found for state " << current_state_ << std::endl;
    }

    // --- Predicate implementations ---
    bool p_isReady() { std::cout << "    pred: p_isReady called\n"; return true; }
    bool p_hasEvent() { std::cout << "    pred: p_hasEvent called\n"; return event_flag_; }

    // --- Action implementations ---
    void a_doSetup() { std::cout << "    action: a_doSetup called\n"; event_flag_ = true; }
    void a_processEvent() { std::cout << "    action: a_processEvent called\n"; event_flag_ = false;}
    void a_enterError() {std::cout << "    action: a_enterError called\n"; }


private:
    std::string_view current_state_;
    std::vector<Transition> transitions_;
    bool event_flag_ = false; // Example data for predicates/actions
};


int main() { // Example usage if this were the main file
    MyCoolFSM fsm("IDLE");
    fsm.step(); // Check IDLE -> READY
    fsm.step(); // Check READY -> IDLE (if p_hasEvent was true)
    fsm.step(); // Check READY -> ERROR (if p_hasEvent was false)
    return 0;
}
